"""
This type stub file was generated by pyright.
"""

from abc import ABC, abstractmethod
from datetime import datetime
from typing import Any, Dict, Generic, List, Literal, Mapping, Optional, Type, TypeVar
from autogen_core import Component, ComponentBase, FunctionCall, Image
from autogen_core.code_executor import CodeBlock, CodeResult
from autogen_core.memory import MemoryContent
from autogen_core.models import FunctionExecutionResult, LLMMessage, RequestUsage, UserMessage
from pydantic import BaseModel, Field, computed_field
from typing_extensions import Annotated, Self

"""
This module defines various message types used for agent-to-agent communication.
Each message type inherits either from the BaseChatMessage class or BaseAgentEvent
class and includes specific fields relevant to the type of message being sent.
"""
class BaseMessage(BaseModel, ABC):
    """Abstract base class for all message types in AgentChat.

    .. warning::

        If you want to create a new message type, do not inherit from this class.
        Instead, inherit from :class:`BaseChatMessage` or :class:`BaseAgentEvent`
        to clarify the purpose of the message type.

    """
    @abstractmethod
    def to_text(self) -> str:
        """Convert the message content to a string-only representation
        that can be rendered in the console and inspected by the user or conditions.
        This is not used for creating text-only content for models.
        For :class:`BaseChatMessage` types, use :meth:`to_model_text` instead."""
        ...
    
    def dump(self) -> Mapping[str, Any]:
        """Convert the message to a JSON-serializable dictionary.

        The default implementation uses the Pydantic model's
        :meth:`model_dump` method to convert the message to a dictionary.
        Datetime objects are automatically converted to ISO format strings
        to ensure JSON serialization compatibility.
        Override this method if you want to customize the serialization
        process or add additional fields to the output.
        """
        ...
    
    @classmethod
    def load(cls, data: Mapping[str, Any]) -> Self:
        """Create a message from a dictionary of JSON-serializable data.

        The default implementation uses the Pydantic model's
        :meth:`model_validate` method to create the message from the data.
        Override this method if you want to customize the deserialization
        process or add additional fields to the input data."""
        ...
    


class BaseChatMessage(BaseMessage, ABC):
    """Abstract base class for chat messages.

    .. note::

        If you want to create a new message type that is used for agent-to-agent
        communication, inherit from this class, or simply use
        :class:`StructuredMessage` if your content type is a subclass of
        Pydantic BaseModel.

    This class is used for messages that are sent between agents in a chat
    conversation. Agents are expected to process the content of the
    message using models and return a response as another :class:`BaseChatMessage`.
    """
    id: str = ...
    source: str
    models_usage: RequestUsage | None = ...
    metadata: Dict[str, str] = ...
    created_at: datetime = ...
    @abstractmethod
    def to_model_text(self) -> str:
        """Convert the content of the message to text-only representation.
        This is used for creating text-only content for models.

        This is not used for rendering the message in console. For that, use
        :meth:`~BaseMessage.to_text`.

        The difference between this and :meth:`to_model_message` is that this
        is used to construct parts of the a message for the model client,
        while :meth:`to_model_message` is used to create a complete message
        for the model client.
        """
        ...
    
    @abstractmethod
    def to_model_message(self) -> UserMessage:
        """Convert the message content to a :class:`~autogen_core.models.UserMessage`
        for use with model client, e.g., :class:`~autogen_core.models.ChatCompletionClient`.
        """
        ...
    


class BaseTextChatMessage(BaseChatMessage, ABC):
    """Base class for all text-only :class:`BaseChatMessage` types.
    It has implementations for :meth:`to_text`, :meth:`to_model_text`,
    and :meth:`to_model_message` methods.

    Inherit from this class if your message content type is a string.
    """
    content: str
    def to_text(self) -> str:
        ...
    
    def to_model_text(self) -> str:
        ...
    
    def to_model_message(self) -> UserMessage:
        ...
    


class BaseAgentEvent(BaseMessage, ABC):
    """Base class for agent events.

    .. note::

        If you want to create a new message type for signaling observable events
        to user and application, inherit from this class.

    Agent events are used to signal actions and thoughts produced by agents
    and teams to user and applications. They are not used for agent-to-agent
    communication and are not expected to be processed by other agents.

    You should override the :meth:`to_text` method if you want to provide
    a custom rendering of the content.
    """
    id: str = ...
    source: str
    models_usage: RequestUsage | None = ...
    metadata: Dict[str, str] = ...
    created_at: datetime = ...


StructuredContentType = TypeVar("StructuredContentType", bound=BaseModel, covariant=True)
class StructuredMessage(BaseChatMessage, Generic[StructuredContentType]):
    """A :class:`BaseChatMessage` type with an unspecified content type.

    To create a new structured message type, specify the content type
    as a subclass of `Pydantic BaseModel <https://docs.pydantic.dev/latest/concepts/models/>`_.

    .. code-block:: python

        from pydantic import BaseModel
        from autogen_agentchat.messages import StructuredMessage


        class MyMessageContent(BaseModel):
            text: str
            number: int


        message = StructuredMessage[MyMessageContent](
            content=MyMessageContent(text="Hello", number=42),
            source="agent1",
        )

        print(message.to_text())  # {"text": "Hello", "number": 42}

    .. code-block:: python

        from pydantic import BaseModel
        from autogen_agentchat.messages import StructuredMessage


        class MyMessageContent(BaseModel):
            text: str
            number: int


        message = StructuredMessage[MyMessageContent](
            content=MyMessageContent(text="Hello", number=42),
            source="agent",
            format_string="Hello, {text} {number}!",
        )

        print(message.to_text())  # Hello, agent 42!

    """
    content: StructuredContentType
    format_string: Optional[str] = ...
    @computed_field
    def type(self) -> str:
        ...
    
    def to_text(self) -> str:
        ...
    
    def to_model_text(self) -> str:
        ...
    
    def to_model_message(self) -> UserMessage:
        ...
    


class StructureMessageConfig(BaseModel):
    """The declarative configuration for the structured output."""
    json_schema: Dict[str, Any]
    format_string: Optional[str] = ...
    content_model_name: str


class StructuredMessageFactory(ComponentBase[StructureMessageConfig], Component[StructureMessageConfig]):
    """:meta private:

    A component that creates structured chat messages from Pydantic models or JSON schemas.

    This component helps you generate strongly-typed chat messages with content defined using a Pydantic model.
    It can be used in declarative workflows where message structure must be validated, formatted, and serialized.

    You can initialize the component directly using a `BaseModel` subclass, or dynamically from a configuration
    object (e.g., loaded from disk or a database).

    ### Example 1: Create from a Pydantic Model

    .. code-block:: python

        from pydantic import BaseModel
        from autogen_agentchat.messages import StructuredMessageFactory


        class TestContent(BaseModel):
            field1: str
            field2: int


        format_string = "This is a string {field1} and this is an int {field2}"
        sm_component = StructuredMessageFactory(input_model=TestContent, format_string=format_string)

        message = sm_component.StructuredMessage(
            source="test_agent", content=TestContent(field1="Hello", field2=42), format_string=format_string
        )

        print(message.to_model_text())  # Output: This is a string Hello and this is an int 42

        config = sm_component.dump_component()

        s_m_dyn = StructuredMessageFactory.load_component(config)
        message = s_m_dyn.StructuredMessage(
            source="test_agent",
            content=s_m_dyn.ContentModel(field1="dyn agent", field2=43),
            format_string=s_m_dyn.format_string,
        )
        print(type(message))  # StructuredMessage[GeneratedModel]
        print(message.to_model_text())  # Output: This is a string dyn agent and this is an int 43

    Attributes:
        component_config_schema (StructureMessageConfig): Defines the configuration structure for this component.
        component_provider_override (str): Path used to reference this component in external tooling.
        component_type (str): Identifier used for categorization (e.g., "structured_message").

    Raises:
        ValueError: If neither `json_schema` nor `input_model` is provided.

    Args:
        json_schema (Optional[str]): JSON schema to dynamically create a Pydantic model.
        input_model (Optional[Type[BaseModel]]): A subclass of `BaseModel` that defines the expected message structure.
        format_string (Optional[str]): Optional string to render content into a human-readable format.
        content_model_name (Optional[str]): Optional name for the generated Pydantic model.
    """
    component_config_schema = ...
    component_provider_override = ...
    component_type = ...
    def __init__(self, json_schema: Optional[Dict[str, Any]] = ..., input_model: Optional[Type[BaseModel]] = ..., format_string: Optional[str] = ..., content_model_name: Optional[str] = ...) -> None:
        ...
    


class TextMessage(BaseTextChatMessage):
    """A text message with string-only content."""
    type: Literal["TextMessage"] = ...


class MultiModalMessage(BaseChatMessage):
    """A multimodal message."""
    content: List[str | Image]
    type: Literal["MultiModalMessage"] = ...
    def to_model_text(self, image_placeholder: str | None = ...) -> str:
        """Convert the content of the message to a string-only representation.
        If an image is present, it will be replaced with the image placeholder
        by default, otherwise it will be a base64 string when set to None.
        """
        ...
    
    def to_text(self, iterm: bool = ...) -> str:
        ...
    
    def to_model_message(self) -> UserMessage:
        ...
    


class StopMessage(BaseTextChatMessage):
    """A message requesting stop of a conversation."""
    type: Literal["StopMessage"] = ...


class HandoffMessage(BaseTextChatMessage):
    """A message requesting handoff of a conversation to another agent."""
    target: str
    context: List[LLMMessage] = ...
    type: Literal["HandoffMessage"] = ...


class ToolCallSummaryMessage(BaseTextChatMessage):
    """A message signaling the summary of tool call results."""
    type: Literal["ToolCallSummaryMessage"] = ...
    tool_calls: List[FunctionCall]
    results: List[FunctionExecutionResult]


class ToolCallRequestEvent(BaseAgentEvent):
    """An event signaling a request to use tools."""
    content: List[FunctionCall]
    type: Literal["ToolCallRequestEvent"] = ...
    def to_text(self) -> str:
        ...
    


class CodeGenerationEvent(BaseAgentEvent):
    """An event signaling code generation event."""
    retry_attempt: int
    content: str
    code_blocks: List[CodeBlock]
    type: Literal["CodeGenerationEvent"] = ...
    def to_text(self) -> str:
        ...
    


class CodeExecutionEvent(BaseAgentEvent):
    """An event signaling code execution event."""
    retry_attempt: int
    result: CodeResult
    type: Literal["CodeExecutionEvent"] = ...
    def to_text(self) -> str:
        ...
    


class ToolCallExecutionEvent(BaseAgentEvent):
    """An event signaling the execution of tool calls."""
    content: List[FunctionExecutionResult]
    type: Literal["ToolCallExecutionEvent"] = ...
    def to_text(self) -> str:
        ...
    


class UserInputRequestedEvent(BaseAgentEvent):
    """An event signaling a that the user proxy has requested user input. Published prior to invoking the input callback."""
    request_id: str
    content: Literal[""] = ...
    type: Literal["UserInputRequestedEvent"] = ...
    def to_text(self) -> str:
        ...
    


class MemoryQueryEvent(BaseAgentEvent):
    """An event signaling the results of memory queries."""
    content: List[MemoryContent]
    type: Literal["MemoryQueryEvent"] = ...
    def to_text(self) -> str:
        ...
    


class ModelClientStreamingChunkEvent(BaseAgentEvent):
    """An event signaling a text output chunk from a model client in streaming mode."""
    content: str
    full_message_id: str | None = ...
    type: Literal["ModelClientStreamingChunkEvent"] = ...
    def to_text(self) -> str:
        ...
    


class ThoughtEvent(BaseAgentEvent):
    """An event signaling the thought process of a model.
    It is used to communicate the reasoning tokens generated by a reasoning model,
    or the extra text content generated by a function call."""
    content: str
    type: Literal["ThoughtEvent"] = ...
    def to_text(self) -> str:
        ...
    


class SelectSpeakerEvent(BaseAgentEvent):
    """An event signaling the selection of speakers for a conversation."""
    content: List[str]
    type: Literal["SelectSpeakerEvent"] = ...
    def to_text(self) -> str:
        ...
    


class SelectorEvent(BaseAgentEvent):
    """An event emitted from the `SelectorGroupChat`."""
    content: str
    type: Literal["SelectorEvent"] = ...
    def to_text(self) -> str:
        ...
    


class MessageFactory:
    """:meta private:

    A factory for creating messages from JSON-serializable dictionaries.

    This is useful for deserializing messages from JSON data.
    """
    def __init__(self) -> None:
        ...
    
    def is_registered(self, message_type: type[BaseAgentEvent | BaseChatMessage]) -> bool:
        """Check if a message type is registered with the factory."""
        ...
    
    def register(self, message_type: type[BaseAgentEvent | BaseChatMessage]) -> None:
        """Register a new message type with the factory."""
        ...
    
    def create(self, data: Mapping[str, Any]) -> BaseAgentEvent | BaseChatMessage:
        """Create a message from a dictionary of JSON-serializable data."""
        ...
    


ChatMessage = Annotated[TextMessage | MultiModalMessage | StopMessage | ToolCallSummaryMessage | HandoffMessage, Field(discriminator="type"),]
AgentEvent = Annotated[ToolCallRequestEvent | ToolCallExecutionEvent | MemoryQueryEvent | UserInputRequestedEvent | ModelClientStreamingChunkEvent | ThoughtEvent | SelectSpeakerEvent | CodeGenerationEvent | CodeExecutionEvent, Field(discriminator="type"),]
__all__ = ["AgentEvent", "BaseMessage", "ChatMessage", "BaseChatMessage", "BaseAgentEvent", "BaseTextChatMessage", "StructuredContentType", "StructuredMessage", "StructuredMessageFactory", "HandoffMessage", "MultiModalMessage", "StopMessage", "TextMessage", "ToolCallExecutionEvent", "ToolCallRequestEvent", "ToolCallSummaryMessage", "MemoryQueryEvent", "UserInputRequestedEvent", "ModelClientStreamingChunkEvent", "ThoughtEvent", "SelectSpeakerEvent", "MessageFactory", "CodeGenerationEvent", "CodeExecutionEvent"]
