"""
This type stub file was generated by pyright.
"""

from typing import Awaitable, Callable, List, Sequence
from autogen_core import Component
from pydantic import BaseModel
from ..base import TerminationCondition
from ..messages import BaseAgentEvent, BaseChatMessage, StopMessage

class StopMessageTerminationConfig(BaseModel):
    ...


class StopMessageTermination(TerminationCondition, Component[StopMessageTerminationConfig]):
    """Terminate the conversation if a StopMessage is received."""
    component_config_schema = ...
    component_provider_override = ...
    def __init__(self) -> None:
        ...
    
    @property
    def terminated(self) -> bool:
        ...
    
    async def __call__(self, messages: Sequence[BaseAgentEvent | BaseChatMessage]) -> StopMessage | None:
        ...
    
    async def reset(self) -> None:
        ...
    


class MaxMessageTerminationConfig(BaseModel):
    max_messages: int
    include_agent_event: bool = ...


class MaxMessageTermination(TerminationCondition, Component[MaxMessageTerminationConfig]):
    """Terminate the conversation after a maximum number of messages have been exchanged.

    Args:
        max_messages: The maximum number of messages allowed in the conversation.
        include_agent_event: If True, include :class:`~autogen_agentchat.messages.BaseAgentEvent` in the message count.
            Otherwise, only include :class:`~autogen_agentchat.messages.BaseChatMessage`. Defaults to False.
    """
    component_config_schema = ...
    component_provider_override = ...
    def __init__(self, max_messages: int, include_agent_event: bool = ...) -> None:
        ...
    
    @property
    def terminated(self) -> bool:
        ...
    
    async def __call__(self, messages: Sequence[BaseAgentEvent | BaseChatMessage]) -> StopMessage | None:
        ...
    
    async def reset(self) -> None:
        ...
    


class TextMentionTerminationConfig(BaseModel):
    text: str
    ...


class TextMentionTermination(TerminationCondition, Component[TextMentionTerminationConfig]):
    """Terminate the conversation if a specific text is mentioned.


    Args:
        text: The text to look for in the messages.
        sources: Check only messages of the specified agents for the text to look for.
    """
    component_config_schema = ...
    component_provider_override = ...
    def __init__(self, text: str, sources: Sequence[str] | None = ...) -> None:
        ...
    
    @property
    def terminated(self) -> bool:
        ...
    
    async def __call__(self, messages: Sequence[BaseAgentEvent | BaseChatMessage]) -> StopMessage | None:
        ...
    
    async def reset(self) -> None:
        ...
    


class FunctionalTermination(TerminationCondition):
    """Terminate the conversation if an functional expression is met.

    Args:
        func (Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], bool] | Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], Awaitable[bool]]): A function that takes a sequence of messages
            and returns True if the termination condition is met, False otherwise.
            The function can be a callable or an async callable.

    Example:

        .. code-block:: python

            import asyncio
            from typing import Sequence

            from autogen_agentchat.conditions import FunctionalTermination
            from autogen_agentchat.messages import BaseAgentEvent, BaseChatMessage, StopMessage


            def expression(messages: Sequence[BaseAgentEvent | BaseChatMessage]) -> bool:
                # Check if the last message is a stop message
                return isinstance(messages[-1], StopMessage)


            termination = FunctionalTermination(expression)


            async def run() -> None:
                messages = [
                    StopMessage(source="agent1", content="Stop"),
                ]
                result = await termination(messages)
                print(result)


            asyncio.run(run())

        .. code-block:: text

            StopMessage(source="FunctionalTermination", content="Functional termination condition met")

    """
    def __init__(self, func: Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], bool] | Callable[[Sequence[BaseAgentEvent | BaseChatMessage]], Awaitable[bool]]) -> None:
        ...
    
    @property
    def terminated(self) -> bool:
        ...
    
    async def __call__(self, messages: Sequence[BaseAgentEvent | BaseChatMessage]) -> StopMessage | None:
        ...
    
    async def reset(self) -> None:
        ...
    


class TokenUsageTerminationConfig(BaseModel):
    max_total_token: int | None
    max_prompt_token: int | None
    max_completion_token: int | None
    ...


class TokenUsageTermination(TerminationCondition, Component[TokenUsageTerminationConfig]):
    """Terminate the conversation if a token usage limit is reached.

    Args:
        max_total_token: The maximum total number of tokens allowed in the conversation.
        max_prompt_token: The maximum number of prompt tokens allowed in the conversation.
        max_completion_token: The maximum number of completion tokens allowed in the conversation.

    Raises:
        ValueError: If none of max_total_token, max_prompt_token, or max_completion_token is provided.
    """
    component_config_schema = ...
    component_provider_override = ...
    def __init__(self, max_total_token: int | None = ..., max_prompt_token: int | None = ..., max_completion_token: int | None = ...) -> None:
        ...
    
    @property
    def terminated(self) -> bool:
        ...
    
    async def __call__(self, messages: Sequence[BaseAgentEvent | BaseChatMessage]) -> StopMessage | None:
        ...
    
    async def reset(self) -> None:
        ...
    


class HandoffTerminationConfig(BaseModel):
    target: str
    ...


class HandoffTermination(TerminationCondition, Component[HandoffTerminationConfig]):
    """Terminate the conversation if a :class:`~autogen_agentchat.messages.HandoffMessage`
    with the given target is received.

    Args:
        target (str): The target of the handoff message.
    """
    component_config_schema = ...
    component_provider_override = ...
    def __init__(self, target: str) -> None:
        ...
    
    @property
    def terminated(self) -> bool:
        ...
    
    async def __call__(self, messages: Sequence[BaseAgentEvent | BaseChatMessage]) -> StopMessage | None:
        ...
    
    async def reset(self) -> None:
        ...
    


class TimeoutTerminationConfig(BaseModel):
    timeout_seconds: float
    ...


class TimeoutTermination(TerminationCondition, Component[TimeoutTerminationConfig]):
    """Terminate the conversation after a specified duration has passed.

    Args:
        timeout_seconds: The maximum duration in seconds before terminating the conversation.
    """
    component_config_schema = ...
    component_provider_override = ...
    def __init__(self, timeout_seconds: float) -> None:
        ...
    
    @property
    def terminated(self) -> bool:
        ...
    
    async def __call__(self, messages: Sequence[BaseAgentEvent | BaseChatMessage]) -> StopMessage | None:
        ...
    
    async def reset(self) -> None:
        ...
    


class ExternalTerminationConfig(BaseModel):
    ...


class ExternalTermination(TerminationCondition, Component[ExternalTerminationConfig]):
    """A termination condition that is externally controlled
    by calling the :meth:`set` method.

    Example:

    .. code-block:: python

        from autogen_agentchat.conditions import ExternalTermination

        termination = ExternalTermination()

        # Run the team in an asyncio task.
        ...

        # Set the termination condition externally
        termination.set()

    """
    component_config_schema = ...
    component_provider_override = ...
    def __init__(self) -> None:
        ...
    
    @property
    def terminated(self) -> bool:
        ...
    
    def set(self) -> None:
        """Set the termination condition to terminated."""
        ...
    
    async def __call__(self, messages: Sequence[BaseAgentEvent | BaseChatMessage]) -> StopMessage | None:
        ...
    
    async def reset(self) -> None:
        ...
    


class SourceMatchTerminationConfig(BaseModel):
    sources: List[str]
    ...


class SourceMatchTermination(TerminationCondition, Component[SourceMatchTerminationConfig]):
    """Terminate the conversation after a specific source responds.

    Args:
        sources (List[str]): List of source names to terminate the conversation.

    Raises:
        TerminatedException: If the termination condition has already been reached.
    """
    component_config_schema = ...
    component_provider_override = ...
    def __init__(self, sources: List[str]) -> None:
        ...
    
    @property
    def terminated(self) -> bool:
        ...
    
    async def __call__(self, messages: Sequence[BaseAgentEvent | BaseChatMessage]) -> StopMessage | None:
        ...
    
    async def reset(self) -> None:
        ...
    


class TextMessageTerminationConfig(BaseModel):
    """Configuration for the TextMessageTermination termination condition."""
    source: str | None = ...


class TextMessageTermination(TerminationCondition, Component[TextMessageTerminationConfig]):
    """Terminate the conversation if a :class:`~autogen_agentchat.messages.TextMessage` is received.

    This termination condition checks for TextMessage instances in the message sequence. When a TextMessage is found,
    it terminates the conversation if either:
    - No source was specified (terminates on any TextMessage)
    - The message source matches the specified source

    Args:
        source (str | None, optional): The source name to match against incoming messages. If None, matches any source.
            Defaults to None.
    """
    component_config_schema = ...
    component_provider_override = ...
    def __init__(self, source: str | None = ...) -> None:
        ...
    
    @property
    def terminated(self) -> bool:
        ...
    
    async def __call__(self, messages: Sequence[BaseAgentEvent | BaseChatMessage]) -> StopMessage | None:
        ...
    
    async def reset(self) -> None:
        ...
    


class FunctionCallTerminationConfig(BaseModel):
    """Configuration for the :class:`FunctionCallTermination` termination condition."""
    function_name: str
    ...


class FunctionCallTermination(TerminationCondition, Component[FunctionCallTerminationConfig]):
    """Terminate the conversation if a :class:`~autogen_core.models.FunctionExecutionResult`
    with a specific name was received.

    Args:
        function_name (str): The name of the function to look for in the messages.

    Raises:
        TerminatedException: If the termination condition has already been reached.
    """
    component_config_schema = ...
    component_provider_override = ...
    def __init__(self, function_name: str) -> None:
        ...
    
    @property
    def terminated(self) -> bool:
        ...
    
    async def __call__(self, messages: Sequence[BaseAgentEvent | BaseChatMessage]) -> StopMessage | None:
        ...
    
    async def reset(self) -> None:
        ...
    
