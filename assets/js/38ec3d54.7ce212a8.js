"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[872],{7255:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"testing/systematic-failure-testing","title":"Systematic Mock LLM Failure Testing","description":"Overview","source":"@site/docs/testing/systematic-failure-testing.md","sourceDirName":"testing","slug":"/testing/systematic-failure-testing","permalink":"/libriscribe2/docs/testing/systematic-failure-testing","draft":false,"unlisted":false,"editUrl":"https://github.com/guerra2fernando/libriscribe2/tree/main/docs/docs/testing/systematic-failure-testing.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"LibriScribe2 Documentation Setup","permalink":"/libriscribe2/docs/setup"},"next":{"title":"Usage Guide","permalink":"/libriscribe2/docs/user-guide/usage"}}');var n=t(4848),r=t(8453);const l={},a="Systematic Mock LLM Failure Testing",c={},o=[{value:"Overview",id:"overview",level:2},{value:"Problem Statement",id:"problem-statement",level:2},{value:"Solution: Parametrized Failure Testing",id:"solution-parametrized-failure-testing",level:2},{value:"Implementation",id:"implementation",level:3},{value:"Test Coverage",id:"test-coverage",level:3},{value:"Call Sequence Analysis",id:"call-sequence-analysis",level:2},{value:"Test Scenarios",id:"test-scenarios",level:2},{value:"Failure Tests (Calls 1-18)",id:"failure-tests-calls-1-18",level:3},{value:"Success Test (Call 19+)",id:"success-test-call-19",level:3},{value:"Benefits",id:"benefits",level:2},{value:"Usage",id:"usage",level:2},{value:"Key Implementation Details",id:"key-implementation-details",level:2}];function d(e){const s={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.header,{children:(0,n.jsx)(s.h1,{id:"systematic-mock-llm-failure-testing",children:"Systematic Mock LLM Failure Testing"})}),"\n",(0,n.jsx)(s.h2,{id:"overview",children:"Overview"}),"\n",(0,n.jsx)(s.p,{children:"This document describes the systematic failure testing framework implemented for the LibriScribe2 project to ensure robust error handling throughout the book creation process."}),"\n",(0,n.jsx)(s.h2,{id:"problem-statement",children:"Problem Statement"}),"\n",(0,n.jsx)(s.p,{children:"The book creation process involves multiple sequential LLM calls. It's critical to verify that the CLI handles failures gracefully at any point in this sequence. Previously, we only tested a few specific failure scenarios, but we needed comprehensive coverage."}),"\n",(0,n.jsx)(s.h2,{id:"solution-parametrized-failure-testing",children:"Solution: Parametrized Failure Testing"}),"\n",(0,n.jsx)(s.h3,{id:"implementation",children:"Implementation"}),"\n",(0,n.jsxs)(s.p,{children:["The test framework uses a ",(0,n.jsx)(s.code,{children:"FailingMockLLMClient"})," that extends the standard ",(0,n.jsx)(s.code,{children:"MockLLMClient"})," with failure injection capabilities:"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:'class FailingMockLLMClient(MockLLMClient):\n    """Mock LLM client that fails after a specified number of calls."""\n\n    def __init__(self, fail_after_calls: int = 1, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.fail_after_calls = fail_after_calls\n        self.call_count = 0\n\n    def generate_content(self, prompt: str, prompt_type: str = "default",\n                        temperature: float = 0.7, language: str = "English",\n                        timeout: int | None = None) -> str:\n        """Generate content but fail after specified number of calls."""\n        self.call_count += 1\n\n        if self.call_count > self.fail_after_calls:\n            raise RuntimeError(f"Mock LLM client failed after {self.fail_after_calls} calls")\n\n        # Return normal mock content for successful calls\n        return super().generate_content(prompt=prompt, prompt_type=prompt_type,\n                                      temperature=temperature, language=language,\n                                      timeout=timeout)\n'})}),"\n",(0,n.jsx)(s.h3,{id:"test-coverage",children:"Test Coverage"}),"\n",(0,n.jsx)(s.p,{children:"The main test uses pytest parametrization to systematically test failures at each call position:"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-python",children:'@pytest.mark.parametrize("fail_after_calls", range(1, 20))  # Test failures from call 1 to 19\ndef test_mock_fails_at_specific_call(self, mock_settings_class, mock_generate_content, fail_after_calls):\n    """Test that CLI fails properly when mock LLM fails at specific call position."""\n'})}),"\n",(0,n.jsx)(s.h2,{id:"call-sequence-analysis",children:"Call Sequence Analysis"}),"\n",(0,n.jsx)(s.p,{children:"Based on analysis of a typical book creation process (3 chapters, 2 characters), the LLM call sequence is:"}),"\n",(0,n.jsxs)(s.table,{children:[(0,n.jsx)(s.thead,{children:(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.th,{children:"Call #"}),(0,n.jsx)(s.th,{children:"Stage"}),(0,n.jsx)(s.th,{children:"Purpose"})]})}),(0,n.jsxs)(s.tbody,{children:[(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"1-4"}),(0,n.jsx)(s.td,{children:"Concept Generation"}),(0,n.jsx)(s.td,{children:"concept, critique, refine, keywords"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"5"}),(0,n.jsx)(s.td,{children:"Outline Generation"}),(0,n.jsx)(s.td,{children:"Main outline"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"6-8"}),(0,n.jsx)(s.td,{children:"Scene Outlines"}),(0,n.jsx)(s.td,{children:"Scene breakdowns for 3 chapters"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"9"}),(0,n.jsx)(s.td,{children:"Character Generation"}),(0,n.jsx)(s.td,{children:"Character profiles"})]}),(0,n.jsxs)(s.tr,{children:[(0,n.jsx)(s.td,{children:"10-18"}),(0,n.jsx)(s.td,{children:"Scene Writing"}),(0,n.jsx)(s.td,{children:"3 scenes \xd7 3 chapters = 9 scenes"})]})]})]}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.strong,{children:"Total Expected Calls: 18"})}),"\n",(0,n.jsx)(s.h2,{id:"test-scenarios",children:"Test Scenarios"}),"\n",(0,n.jsx)(s.h3,{id:"failure-tests-calls-1-18",children:"Failure Tests (Calls 1-18)"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Purpose"}),": Verify that failures at any point in the sequence are handled gracefully"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Expected Behavior"}),": CLI should raise ",(0,n.jsx)(s.code,{children:"RuntimeError"}),' with message "Book creation failed"']}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Verification"}),": Confirms the failure occurred at the expected call number"]}),"\n"]}),"\n",(0,n.jsx)(s.h3,{id:"success-test-call-19",children:"Success Test (Call 19+)"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Purpose"}),": Verify that when no failure is programmed, the process completes successfully"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Expected Behavior"}),": All 18 calls complete successfully"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Verification"}),": Confirms exactly 18 calls were made"]}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"benefits",children:"Benefits"}),"\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Comprehensive Coverage"}),": Tests every possible failure point in the book creation process"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Regression Prevention"}),": Ensures new changes don't break error handling"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Systematic Approach"}),": Uses parametrization to avoid code duplication"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Precise Verification"}),": Confirms failures occur at the exact expected call position"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Boundary Testing"}),": Verifies both failure and success scenarios"]}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"usage",children:"Usage"}),"\n",(0,n.jsx)(s.p,{children:"Run the systematic failure tests:"}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{className:"language-bash",children:"# Run all failure scenario tests\nhatch run test tests/test_mock_failure_scenarios.py -v\n\n# Run specific failure position\nhatch run test tests/test_mock_failure_scenarios.py::TestMockFailureScenarios::test_mock_fails_at_specific_call[5] -v\n\n# Run success scenario\nhatch run test tests/test_mock_failure_scenarios.py::TestMockFailureScenarios::test_mock_succeeds_with_no_failure -v\n"})}),"\n",(0,n.jsx)(s.h2,{id:"key-implementation-details",children:"Key Implementation Details"}),"\n",(0,n.jsxs)(s.ol,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Unique Project Names"}),": Each test uses a unique suffix to avoid directory conflicts"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Proper Cleanup"}),": Tests use temporary directories that are cleaned up automatically"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Mock Settings"}),": Each test creates isolated mock settings to avoid interference"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Call Counting"}),": The failing client accurately tracks and reports call counts"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Error Message Matching"}),": Tests verify the specific error message format expected by users"]}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"This systematic approach ensures that LibriScribe2's error handling is robust and reliable across all stages of the book creation process."})]})}function h(e={}){const{wrapper:s}={...(0,r.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},8453:(e,s,t)=>{t.d(s,{R:()=>l,x:()=>a});var i=t(6540);const n={},r=i.createContext(n);function l(e){const s=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:l(e.components),i.createElement(r.Provider,{value:s},e.children)}}}]);