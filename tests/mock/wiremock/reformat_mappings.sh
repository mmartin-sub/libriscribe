#!/bin/bash

# --- Configuration ---
# Get the directory where the script itself is located. This makes the script portable.
SCRIPT_DIR=$(dirname "$0")

# Set the directories for mappings and files relative to the script's location.
# This ensures it finds them correctly, regardless of where you call the script from.
MAPPINGS_DIR="$SCRIPT_DIR/wiremock-recordings/mappings"
FILES_DIR="$SCRIPT_DIR/wiremock-recordings/__files"

# --- Pre-flight Checks ---
# Check if jq is installed, as it's required for the script.
if ! command -v jq &> /dev/null
then
    echo "Error: jq is not installed. Please install it to run this script."
    echo "On macOS: brew install jq"
    echo "On Debian/Ubuntu: sudo apt-get install jq"
    exit 1
fi

# Check if the target directory for mappings exists.
if [ ! -d "$MAPPINGS_DIR" ]; then
    echo "Error: Mappings directory not found at '$MAPPINGS_DIR'"
    exit 1
fi

# --- Main Processing Loop ---
echo "Starting the reformatting process..."
echo "Looking for mappings in: $MAPPINGS_DIR"

# Find all original mapping files generated by WireMock.
for file in "$MAPPINGS_DIR"/mapping-*.json; do
    # Check if any files were found to avoid errors on an empty run.
    if [ ! -f "$file" ]; then
        echo "No new mapping files found to process."
        break
    fi

    echo "----------------------------------------"
    echo "Processing: $file"

    # 1. Extract the original body file's name from the mapping.
    original_body_filename=$(jq -r '.response.bodyFileName' "$file")

    # 2. Create a new, clean base name for the mock.
    #    e.g., "mapping-v1-chat-completions-ayqYi.json" -> "mock_chat_completions"
    new_base_name=$(basename "$file" .json | sed -E 's/mapping-v1-(.*)-[a-zA-Z0-9]+/\1/' | tr '-' '_')
    new_mock_name="mock_${new_base_name}"

    new_mapping_filename="${MAPPINGS_DIR}/${new_mock_name}.json"
    new_body_filename_path="${FILES_DIR}/${new_mock_name}_body.json"
    new_body_filename_ref="${new_mock_name}_body.json" # The name used inside the mapping

    # 3. The core jq transformation.
    jq --arg name "$new_mock_name" \
       --arg body_ref "$new_body_filename_ref" \
    '
      # Define the new, clean structure for the mapping file.
      {
        "name": $name,
        "request": {
          "url": .request.url,
          "method": .request.method,
          "bodyPatterns": [
            {
              # This is a much more robust matcher.
              # It checks "Does the request body JSON have a 'messages' key at the top level?"
              "matchesJsonPath": "$.messages"
            }
          ]
        },
        "response": {
          "status": .response.status,
          # Use the new, clean body file name.
          "bodyFileName": $body_ref,
          # Keep only the essential headers.
          "headers": {
            "Content-Type": "application/json"
          }
        }
      }
    ' "$file" > "$new_mapping_filename"

    # 4. Verify the transformation and perform file operations.
    if [ $? -eq 0 ]; then
        echo "  - Created new mapping: $new_mapping_filename"

        # Rename the corresponding body file.
        if [ -f "${FILES_DIR}/${original_body_filename}" ]; then
            mv "${FILES_DIR}/${original_body_filename}" "$new_body_filename_path"
            echo "  - Renamed body file to: $new_body_filename_path"
        else
            echo "  - Warning: Original body file not found: ${FILES_DIR}/${original_body_filename}"
        fi

        # Remove the original, now-processed mapping file.
        rm "$file"
        echo "  - Removed original file: $file"
    else
        echo "  - Error: Failed to process $file with jq."
    fi
done

echo "----------------------------------------"
echo "Script finished."
